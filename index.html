<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Magnet Letters Final</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ccapture.js/1.1.0/CCapture.all.min.js"></script>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; font-family: sans-serif; }
    #canvasWrapper { position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 1; }
    #togglePanelBtn {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 20;
      background: #fff;
      padding: 4px 10px;
      border-radius: 6px;
      border: 1px solid #aaa;
      cursor: pointer;
    }
    #controls {
      position: fixed;
      top: 50px;
      left: 10px;
      background: rgba(255, 255, 255, 0.95);
      padding: 10px;
      border-radius: 8px;
      z-index: 10;
      max-width: 320px;
      font-size: 14px;
      display: none;
    }
    textarea { width: 100%; height: 60px; }
  </style>
</head>
<body>
  <button id="togglePanelBtn" onclick="toggleControls()">‚ò∞ Panel</button>
  <div id="controls">
    <label>Canvas Size: W <input id="canvasW" type="number" value="1040" style="width:60px"> H <input id="canvasH" type="number" value="735" style="width:60px"></label><br>
    <label>Text: <textarea id="textInputBox"></textarea></label><br>
    <label>Font Size: <input type="number" id="fontSize" value="20"></label><br>
    <label>Line Spacing: <input type="number" id="lineSpacing" value="28"></label><br>
    <label>Easing: <input type="range" id="easing" min="0.01" max="0.3" step="0.01" value="0.1"></label><br>
    <label>Font Color: <input type="color" id="fontColor" value="#000000"></label>
    <label>BG Color: <input type="color" id="bgColor" value="#ffffff"></label><br>
    <label>Upload Font: <input type="file" id="fontUpload" accept=".ttf,.otf"></label><br>
    <label>Upload BG Image/Video: <input type="file" id="bgUpload" accept="image/*,video/*"></label><br>
    <button onclick="startRecording()">üé• Start Recording</button>
    <button onclick="stopRecording()">‚èπ Stop</button>
    <button onclick="saveCanvasImage()">üñº Export JPG</button>
  </div>
  <div id="canvasWrapper"></div>
  <script>
    let canvas, font, capture, bgMedia = null, isVideo = false;
    let letters = [], centerIndex = -1, activateFrame = [], frameCounter = 0;
    let recording = false;

    const defaultText = `IntheSbus,intherushhour.Achapofabout26,felt hatwithacordinsteadofaribbon,necktoolong,asifsomeone‚Äôs beenhavingatug-of-warwithit.Peoplegettingoff.Thechapin questiongetsannoyedwithoneofthemenstandingnexttohim. Heaccuseshimofjostlinghimeverytimeanyonegoespast. Asnivellingtonewhichismeanttobeaggressive.Whenhesees avacantseathethrowshimselfontoit.Twohourslater, ImeethimintheCourdeRome,infrontofthegareSaint-Lazare. He‚Äôswithafriendwho‚Äôssaying:‚ÄúYououghttogetanextrabutton putonyourovercoat.‚ÄùHeshowshimwhere(atthelapels)andwhy.`;

    function preload() {
      font = loadFont("https://cdnjs.cloudflare.com/ajax/libs/topcoat/0.8.0/font/SourceCodePro-Regular.otf");
    }

    function setup() {
      canvas = createCanvas(parseInt(canvasW.value), parseInt(canvasH.value));
      canvas.parent("canvasWrapper");
      textFont(font);
      textSize(parseInt(fontSize.value));
      textInputBox.value = defaultText;
      rebuildLetters();
      fontUpload.addEventListener("change", handleFontUpload);
      bgUpload.addEventListener("change", handleBGUpload);
      ["textInputBox", "fontSize", "lineSpacing", "canvasW", "canvasH"].forEach(id => {
        document.getElementById(id).addEventListener("input", rebuildLetters);
      });
    }

    function draw() {
      if (width !== parseInt(canvasW.value) || height !== parseInt(canvasH.value)) {
        resizeCanvas(parseInt(canvasW.value), parseInt(canvasH.value));
        rebuildLetters();
      }

      background(bgColor.value);

      if (bgMedia) {
        if (isVideo && bgMedia.elt.readyState >= 2) image(bgMedia, 0, 0, width, height);
        else if (!isVideo) image(bgMedia, 0, 0, width, height);
      }

      fill(fontColor.value);
      textFont(font);
      textSize(parseInt(fontSize.value));

      if (centerIndex !== -1) {
        updateActivation();
        applyMagnetLayout(centerIndex);
      }

      for (let l of letters) {
        if (l.active) {
          let diff = l.targetX - l.x;
          l.x += abs(diff) < 0.5 ? diff : diff * parseFloat(easing.value);
        }
        text(l.char, l.x, l.y);
      }

      if (recording && capture) capture.capture(canvas.elt);
      frameCounter++;
    }

    function mousePressed() {
      for (let i = 0; i < letters.length; i++) {
        if (dist(mouseX, mouseY, letters[i].x + letters[i].w/2, letters[i].y + 10) < 10) {
          centerIndex = i;
          frameCounter = 0;
          setupActivation(centerIndex);
          break;
        }
      }
    }

    function rebuildLetters() {
      letters = [];
      let fs = parseInt(fontSize.value);
      let spacing = parseInt(lineSpacing.value);
      let str = textInputBox.value;
      let charsPerRow = floor(width / (fs * 0.6));
      textSize(fs);
      for (let i = 0; i < str.length; i++) {
        let col = i % charsPerRow;
        let row = floor(i / charsPerRow);
        let x = col * fs * 0.6 + 20;
        let y = row * spacing + 20;
        let bounds = font.textBounds(str[i], 0, 0, fs);
        letters.push({ char: str[i], x, y, baseX: x, baseY: y, targetX: x, w: bounds.w, row, index: i, active: false });
      }
      centerIndex = -1;
    }

    function setupActivation(centerIdx) {
      activateFrame = new Array(letters.length).fill(Infinity);
      letters.forEach(l => l.active = false);
      let row = letters[centerIdx].row;
      let rowLetters = letters.filter(l => l.row === row);
      let centerInRow = rowLetters.findIndex(l => l.index === centerIdx);
      activateFrame[centerIdx] = 0;
      for (let layer = 1;; layer++) {
        let moved = false;
        if (centerInRow - layer >= 0) {
          activateFrame[rowLetters[centerInRow - layer].index] = layer * 10;
          moved = true;
        }
        if (centerInRow + layer < rowLetters.length) {
          activateFrame[rowLetters[centerInRow + layer].index] = layer * 10;
          moved = true;
        }
        if (!moved) break;
      }
    }

    function updateActivation() {
      for (let i = 0; i < letters.length; i++) {
        if (frameCounter >= activateFrame[i]) letters[i].active = true;
      }
    }

    function handleFontUpload(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(f) {
        font = loadFont(f.target.result, () => {
          textFont(font);
          rebuildLetters();
        });
      };
      reader.readAsDataURL(file);
    }

    function handleBGUpload(e) {
      const file = e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      if (file.type.startsWith("video")) {
        bgMedia = createVideo(url, () => bgMedia.loop());
        bgMedia.hide();
        isVideo = true;
      } else {
        loadImage(url, img => { bgMedia = img; isVideo = false; });
      }
    }

    function startRecording() {
      capture = new CCapture({ format: 'webm', framerate: 30 });
      capture.start();
      recording = true;
    }

    function stopRecording() {
      if (capture) {
        capture.stop();
        capture.save();
        recording = false;
      }
    }

    function saveCanvasImage() {
      saveCanvas('magnet_letters_frame', 'jpg');
    }

    function toggleControls() {
      const el = document.getElementById('controls');
      el.style.display = el.style.display === 'none' ? 'block' : 'none';
    }
  </script>
</body>
</html>